
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Restricted Boltzmann Machines (RBM) &#8212; DeepLearning 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deep Belief Networks" href="DBN.html" />
    <link rel="prev" title="Stacked Denoising Autoencoders (SdA)" href="SdA.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-168290-9']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="DBN.html" title="Deep Belief Networks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SdA.html" title="Stacked Denoising Autoencoders (SdA)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">DeepLearning 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Restricted Boltzmann Machines (RBM)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="restricted-boltzmann-machines-rbm">
<span id="rbm"></span><h1>Restricted Boltzmann Machines (RBM)<a class="headerlink" href="#restricted-boltzmann-machines-rbm" title="Permalink to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section assumes the reader has already read through <a class="reference internal" href="logreg.html"><span class="doc">Classifying MNIST digits using Logistic Regression</span></a>
and <a class="reference internal" href="mlp.html"><span class="doc">Multilayer Perceptron</span></a>. Additionally it uses the following Theano functions
and concepts: <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html?highlight=tanh">T.tanh</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#using-shared-variables">shared variables</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/adding.html#adding-two-scalars">basic arithmetic ops</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#computing-gradients">T.grad</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#using-random-numbers">Random numbers</a>, <a class="reference external" href="http://deeplearning.net/software/theano/library/config.html#config.floatX">floatX</a> and <a class="reference external" href="http://deeplearning.net/software/theano/library/scan.html">scan</a>. If you intend to run the code on GPU also read <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/using_gpu.html">GPU</a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code for this section is available for download <a class="reference external" href="http://deeplearning.net/tutorial/code/rbm.py">here</a>.</p>
</div>
<section id="energy-based-models-ebm">
<h2>Energy-Based Models (EBM)<a class="headerlink" href="#energy-based-models-ebm" title="Permalink to this heading">¶</a></h2>
<p><strong>Energy-based</strong> models associate a scalar energy to each configuration of the
variables of interest. Learning corresponds to modifying that energy function
so that its shape has desirable properties. For example, we would like
plausible or desirable configurations to have low energy.  Energy-based
probabilistic models define a probability distribution through an energy
function, as follows:</p>
<div class="math notranslate nohighlight" id="equation-energy1">
<span class="eqno">(1)<a class="headerlink" href="#equation-energy1" title="Permalink to this equation">¶</a></span>\[p(x) = \frac {e^{-E(x)}} {Z}.\]</div>
<p>The normalizing factor <span class="math notranslate nohighlight">\(Z\)</span> is called the <strong>partition function</strong> by analogy
with physical systems.</p>
<div class="math notranslate nohighlight">
\[Z = \sum_x e^{-E(x)}\]</div>
<p>An energy-based model can be learnt by performing (stochastic) gradient
descent on the empirical negative log-likelihood of the training data. As for
the logistic regression we will first define the log-likelihood and then the
loss function as being the negative log-likelihood.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathcal{L}(\theta, \mathcal{D}) = \frac{1}{N} \sum_{x^{(i)} \in
\mathcal{D}} \log\ p(x^{(i)})\\
\ell (\theta, \mathcal{D}) = - \mathcal{L} (\theta, \mathcal{D})\end{split}\]</div>
<p>using the stochastic gradient <span class="math notranslate nohighlight">\(-\frac{\partial  \log p(x^{(i)})}{\partial
\theta}\)</span>, where <span class="math notranslate nohighlight">\(\theta\)</span> are the parameters of the model.</p>
<p><strong>EBMs with Hidden Units</strong></p>
<p>In many cases of interest, we do not observe the example <span class="math notranslate nohighlight">\(x\)</span> fully, or we
want to introduce some non-observed variables to increase the expressive power
of the model. So we consider an observed part (still denoted <span class="math notranslate nohighlight">\(x\)</span> here) and a
<strong>hidden</strong> part <span class="math notranslate nohighlight">\(h\)</span>. We can then write:</p>
<div class="math notranslate nohighlight" id="equation-energy2">
<span class="eqno">(2)<a class="headerlink" href="#equation-energy2" title="Permalink to this equation">¶</a></span>\[ P(x) = \sum_h P(x,h) = \sum_h \frac{e^{-E(x,h)}}{Z}.\]</div>
<p>In such cases, to map this formulation to one similar to Eq. <a class="reference internal" href="#equation-energy1">(1)</a>, we
introduce the notation (inspired from physics) of <strong>free energy</strong>, defined as
follows:</p>
<div class="math notranslate nohighlight" id="equation-free-energy">
<span class="eqno">(3)<a class="headerlink" href="#equation-free-energy" title="Permalink to this equation">¶</a></span>\[ \mathcal{F}(x) = - \log \sum_h e^{-E(x,h)}\]</div>
<p>which allows us to write,</p>
<div class="math notranslate nohighlight">
\[&amp;P(x) = \frac{e^{-\mathcal{F}(x)}}{Z} \text{ with } Z=\sum_x e^{-\mathcal{F}(x)}.\]</div>
<p>The data negative log-likelihood gradient then has a particularly interesting
form.</p>
<div class="math notranslate nohighlight" id="equation-free-energy-grad">
<span class="eqno">(4)<a class="headerlink" href="#equation-free-energy-grad" title="Permalink to this equation">¶</a></span>\[- \frac{\partial  \log p(x)}{\partial \theta}
 &amp;= \frac{\partial \mathcal{F}(x)}{\partial \theta} -
       \sum_{\tilde{x}} p(\tilde{x}) \
           \frac{\partial \mathcal{F}(\tilde{x})}{\partial \theta}.\]</div>
<p>Notice that the above gradient contains two terms, which are referred to as
the <strong>positive</strong> and <strong>negative phase</strong>. The terms positive and negative do
not refer to the sign of each term in the equation, but rather reflect their
effect on the probability density defined by the model. The first term
increases the probability of training data (by reducing the corresponding free
energy), while the second term decreases the probability of samples generated
by the model.</p>
<p>It is usually difficult to determine this gradient analytically, as it
involves the computation of
<span class="math notranslate nohighlight">\(E_P [ \frac{\partial \mathcal{F}(x)} {\partial \theta} ]\)</span>. This is
nothing less than an expectation over all possible configurations of the input
<span class="math notranslate nohighlight">\(x\)</span> (under the distribution <span class="math notranslate nohighlight">\(P\)</span> formed by the model) !</p>
<p>The first step in making this computation tractable is to estimate the
expectation using a fixed number of model samples. Samples used to estimate the
negative phase gradient are referred to as <strong>negative particles</strong>, which are
denoted as <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>. The gradient can then be written as:</p>
<div class="math notranslate nohighlight" id="equation-bm-grad">
<span class="eqno">(5)<a class="headerlink" href="#equation-bm-grad" title="Permalink to this equation">¶</a></span>\[- \frac{\partial \log p(x)}{\partial \theta}
 &amp;\approx
  \frac{\partial \mathcal{F}(x)}{\partial \theta} -
   \frac{1}{|\mathcal{N}|}\sum_{\tilde{x} \in \mathcal{N}} \
   \frac{\partial \mathcal{F}(\tilde{x})}{\partial \theta}.\]</div>
<p>where we would ideally like elements <span class="math notranslate nohighlight">\(\tilde{x}\)</span> of <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> to be sampled
according to <span class="math notranslate nohighlight">\(P\)</span> (i.e. we are doing Monte-Carlo).
With the above formula, we almost have a pratical, stochastic algorithm for
learning an EBM. The only missing ingredient is how to extract these negative
particles <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>. While the statistical literature abounds with
sampling methods, Markov Chain Monte Carlo methods are especially well suited
for models such as the Restricted Boltzmann Machines (RBM), a specific type of
EBM.</p>
</section>
<section id="id1">
<h2>Restricted Boltzmann Machines (RBM)<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>Boltzmann Machines (BMs) are a particular form of log-linear Markov Random Field (MRF),
i.e., for which the energy function is linear in its free parameters. To make
them powerful enough to represent complicated distributions (i.e., go from the
limited parametric setting to a non-parametric one), we consider that some of
the variables are never observed (they are called hidden). By having more hidden
variables (also called hidden units), we can increase the modeling capacity
of the Boltzmann Machine (BM).
Restricted Boltzmann Machines further restrict BMs to
those without visible-visible and hidden-hidden connections.  A graphical
depiction of an RBM is shown below.</p>
<img alt="_images/rbm.png" class="align-center" src="_images/rbm.png" />
<p>The energy function <span class="math notranslate nohighlight">\(E(v,h)\)</span> of an RBM is defined as:</p>
<div class="math notranslate nohighlight" id="equation-rbm-energy">
<span class="eqno">(6)<a class="headerlink" href="#equation-rbm-energy" title="Permalink to this equation">¶</a></span>\[E(v,h) = - b'v - c'h - h'Wv\]</div>
<p>where <span class="math notranslate nohighlight">\(W\)</span> represents the weights connecting hidden and visible units and
<span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span> are the offsets of the visible and hidden layers
respectively.</p>
<p>This translates directly to the following free energy formula:</p>
<div class="math notranslate nohighlight">
\[\mathcal{F}(v)= - b'v - \sum_i \log \sum_{h_i} e^{h_i (c_i + W_i v)}.\]</div>
<p>Because of the specific structure of RBMs, visible and hidden units are
conditionally independent given one-another. Using this property, we can
write:</p>
<div class="math notranslate nohighlight">
\[\begin{split}p(h|v) &amp;= \prod_i p(h_i|v) \\
p(v|h) &amp;= \prod_j p(v_j|h).\end{split}\]</div>
<p><strong>RBMs with binary units</strong></p>
<p>In the commonly studied case of using binary units (where <span class="math notranslate nohighlight">\(v_j\)</span> and <span class="math notranslate nohighlight">\(h_i \in
\{0,1\}\)</span>), we obtain from Eq. <a class="reference internal" href="#equation-rbm-energy">(6)</a> and <a class="reference internal" href="#equation-energy2">(2)</a>, a probabilistic
version of the usual neuron activation function:</p>
<div class="math notranslate nohighlight" id="equation-rbm-propup">
<span class="eqno">(7)<a class="headerlink" href="#equation-rbm-propup" title="Permalink to this equation">¶</a></span>\[\begin{split}P(h_i=1|v) = sigm(c_i + W_i v) \\\end{split}\]</div>
<div class="math notranslate nohighlight" id="equation-rbm-propdown">
<span class="eqno">(8)<a class="headerlink" href="#equation-rbm-propdown" title="Permalink to this equation">¶</a></span>\[P(v_j=1|h) = sigm(b_j + W'_j h)\]</div>
<p>The free energy of an RBM with binary units further simplifies to:</p>
<div class="math notranslate nohighlight" id="equation-rbm-free-energy">
<span class="eqno">(9)<a class="headerlink" href="#equation-rbm-free-energy" title="Permalink to this equation">¶</a></span>\[\mathcal{F}(v)= - b'v - \sum_i \log(1 + e^{(c_i + W_i v)}).\]</div>
<p><strong>Update Equations with Binary Units</strong></p>
<p>Combining Eqs. <a class="reference internal" href="#equation-bm-grad">(5)</a> with <a class="reference internal" href="#equation-rbm-free-energy">(9)</a>, we obtain the
following log-likelihood gradients for an RBM with binary units:</p>
<div class="math notranslate nohighlight" id="equation-rbm-grad">
<span class="eqno">(10)<a class="headerlink" href="#equation-rbm-grad" title="Permalink to this equation">¶</a></span>\[\begin{split}- \frac{\partial{ \log p(v)}}{\partial W_{ij}} &amp;=
    E_v[p(h_i|v) \cdot v_j]
    - v^{(i)}_j \cdot sigm(W_i \cdot v^{(i)} + c_i) \\
-\frac{\partial{ \log p(v)}}{\partial c_i} &amp;=
    E_v[p(h_i|v)] - sigm(W_i \cdot v^{(i)})  \\
-\frac{\partial{ \log p(v)}}{\partial b_j} &amp;=
    E_v[p(v_j|h)] - v^{(i)}_j\end{split}\]</div>
<p>For a more detailed derivation of these equations, we refer the reader to the
following <a class="reference external" href="http://www.iro.umontreal.ca/~lisa/twiki/bin/view.cgi/Public/DBNEquations">page</a>,
or to section 5 of <a class="reference external" href="http://www.iro.umontreal.ca/%7Elisa/publications2/index.php/publications/show/239">Learning Deep Architectures for AI</a>. We will however not use these formulas, but rather get the gradient using Theano <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#computing-gradients">T.grad</a>
from equation <a class="reference internal" href="#equation-free-energy-grad">(4)</a>.</p>
</section>
<section id="sampling-in-an-rbm">
<h2>Sampling in an RBM<a class="headerlink" href="#sampling-in-an-rbm" title="Permalink to this heading">¶</a></h2>
<p>Samples of <span class="math notranslate nohighlight">\(p(x)\)</span> can be obtained by running a Markov chain to
convergence, using Gibbs sampling as the transition operator.</p>
<p>Gibbs sampling of the joint of N random variables <span class="math notranslate nohighlight">\(S=(S_1, ... , S_N)\)</span>
is done through a sequence of N sampling sub-steps of the form
<span class="math notranslate nohighlight">\(S_i \sim p(S_i | S_{-i})\)</span> where <span class="math notranslate nohighlight">\(S_{-i}\)</span> contains the <span class="math notranslate nohighlight">\(N-1\)</span>
other random variables in <span class="math notranslate nohighlight">\(S\)</span> excluding <span class="math notranslate nohighlight">\(S_i\)</span>.</p>
<p>For RBMs, <span class="math notranslate nohighlight">\(S\)</span> consists of the set of visible and hidden units. However,
since they are conditionally independent, one can perform block Gibbs
sampling. In this setting, visible units are sampled simultaneously given
fixed values of the hidden units. Similarly, hidden units are sampled
simultaneously given the visibles. A step in the Markov chain is thus taken as
follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}h^{(n+1)} &amp;\sim sigm(W'v^{(n)} + c) \\
v^{(n+1)} &amp;\sim sigm(W h^{(n+1)} + b),\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(h^{(n)}\)</span> refers to the set of all hidden units at the n-th step of
the Markov chain. What it means is that, for example, <span class="math notranslate nohighlight">\(h^{(n+1)}_i\)</span> is
randomly chosen to be 1 (versus 0) with probability <span class="math notranslate nohighlight">\(sigm(W_i'v^{(n)} + c_i)\)</span>,
and similarly,
<span class="math notranslate nohighlight">\(v^{(n+1)}_j\)</span> is
randomly chosen to be 1 (versus 0) with probability <span class="math notranslate nohighlight">\(sigm(W_{.j} h^{(n+1)} + b_j)\)</span>.</p>
<p>This can be illustrated graphically:</p>
<img alt="_images/markov_chain.png" class="align-center" src="_images/markov_chain.png" />
<p>As <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>, samples <span class="math notranslate nohighlight">\((v^{(t)}, h^{(t)})\)</span> are
guaranteed to be accurate samples of <span class="math notranslate nohighlight">\(p(v,h)\)</span>.</p>
<p>In theory, each parameter update in the learning process would require running
one such chain to convergence. It is needless to say that doing so would be
prohibitively expensive. As such, several algorithms have been devised for
RBMs, in order to efficiently sample from <span class="math notranslate nohighlight">\(p(v,h)\)</span> during the learning
process.</p>
<section id="contrastive-divergence-cd-k">
<h3>Contrastive Divergence (CD-k)<a class="headerlink" href="#contrastive-divergence-cd-k" title="Permalink to this heading">¶</a></h3>
<p>Contrastive Divergence uses two tricks to speed up the sampling process:</p>
<ul class="simple">
<li><p>since we eventually want <span class="math notranslate nohighlight">\(p(v) \approx p_{train}(v)\)</span> (the true, underlying
distribution of the data), we initialize the Markov chain with a training
example (i.e., from a distribution that is expected to be close to <span class="math notranslate nohighlight">\(p\)</span>,
so that the chain will be already close to having converged to its final distribution <span class="math notranslate nohighlight">\(p\)</span>).</p></li>
<li><p>CD does not wait for the chain to converge. Samples are obtained after only
k-steps of Gibbs sampling. In pratice, <span class="math notranslate nohighlight">\(k=1\)</span> has been shown to work
surprisingly well.</p></li>
</ul>
</section>
<section id="persistent-cd">
<h3>Persistent CD<a class="headerlink" href="#persistent-cd" title="Permalink to this heading">¶</a></h3>
<p>Persistent CD <a class="reference internal" href="references.html#tieleman08" id="id2"><span>[Tieleman08]</span></a> uses another approximation for sampling from
<span class="math notranslate nohighlight">\(p(v,h)\)</span>.  It relies on a single Markov chain, which has a persistent
state (i.e., not restarting a chain for each observed example). For each
parameter update, we extract new samples by simply running the chain for
k-steps. The state of the chain is then preserved for subsequent updates.</p>
<p>The general intuition is that if parameter updates are small enough compared
to the mixing rate of the chain, the Markov chain should be able to “catch up”
to changes in the model.</p>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">¶</a></h2>
<p>We construct an <code class="docutils literal notranslate"><span class="pre">RBM</span></code> class. The parameters of the network can either be
initialized by the constructor or can be passed as arguments. This option is
useful when an RBM is used as the building block of a deep network, in which
case the weight matrix and the hidden layer bias is shared with the
corresponding sigmoidal layer of an MLP network.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RBM</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Restricted Boltzmann Machine (RBM)  &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_visible</span><span class="o">=</span><span class="mi">784</span><span class="p">,</span>
        <span class="n">n_hidden</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hbias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vbias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">numpy_rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">theano_rng</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RBM constructor. Defines the parameters of the model along with</span>
<span class="sd">        basic operations for inferring hidden from visible (and vice-versa),</span>
<span class="sd">        as well as for performing CD updates.</span>

<span class="sd">        :param input: None for standalone RBMs or symbolic variable if RBM is</span>
<span class="sd">        part of a larger graph.</span>

<span class="sd">        :param n_visible: number of visible units</span>

<span class="sd">        :param n_hidden: number of hidden units</span>

<span class="sd">        :param W: None for standalone RBMs or symbolic variable pointing to a</span>
<span class="sd">        shared weight matrix in case RBM is part of a DBN network; in a DBN,</span>
<span class="sd">        the weights are shared between RBMs and layers of a MLP</span>

<span class="sd">        :param hbias: None for standalone RBMs or symbolic variable pointing</span>
<span class="sd">        to a shared hidden units bias vector in case RBM is part of a</span>
<span class="sd">        different network</span>

<span class="sd">        :param vbias: None for standalone RBMs or a symbolic variable</span>
<span class="sd">        pointing to a shared visible units bias</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_visible</span> <span class="o">=</span> <span class="n">n_visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hidden</span> <span class="o">=</span> <span class="n">n_hidden</span>

        <span class="k">if</span> <span class="n">numpy_rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create a number generator</span>
            <span class="n">numpy_rng</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">theano_rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theano_rng</span> <span class="o">=</span> <span class="n">RandomStreams</span><span class="p">(</span><span class="n">numpy_rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># W is initialized with `initial_W` which is uniformely</span>
            <span class="c1"># sampled from -4*sqrt(6./(n_visible+n_hidden)) and</span>
            <span class="c1"># 4*sqrt(6./(n_hidden+n_visible)) the output of uniform if</span>
            <span class="c1"># converted using asarray to dtype theano.config.floatX so</span>
            <span class="c1"># that the code is runable on GPU</span>
            <span class="n">initial_W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="n">numpy_rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">high</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_visible</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
            <span class="p">)</span>
            <span class="c1"># theano shared variables for weights and biases</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">initial_W</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hbias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create shared variable for hidden units bias</span>
            <span class="n">hbias</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_hidden</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hbias&#39;</span><span class="p">,</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">vbias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create shared variable for visible units bias</span>
            <span class="n">vbias</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_visible</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;vbias&#39;</span><span class="p">,</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># initialize input layer for standalone RBM or layer0 of DBN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">input</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">W</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hbias</span> <span class="o">=</span> <span class="n">hbias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vbias</span> <span class="o">=</span> <span class="n">vbias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span> <span class="o">=</span> <span class="n">theano_rng</span>
        <span class="c1"># **** WARNING: It is not a good idea to put things in this list</span>
        <span class="c1"># other than shared variables created in this function.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hbias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbias</span><span class="p">]</span>
</pre></div>
</div>
<p>Next step is to define functions which construct the symbolic graph associated
with Eqs. <a class="reference internal" href="#equation-rbm-propup">(7)</a> - <a class="reference internal" href="#equation-rbm-propdown">(8)</a>. The code is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">propup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This function propagates the visible units activation upwards to</span>
<span class="sd">        the hidden units</span>

<span class="sd">        Note that we return also the pre-sigmoid activation of the</span>
<span class="sd">        layer. As it will turn out later, due to how Theano deals with</span>
<span class="sd">        optimizations, this symbolic variable will be needed to write</span>
<span class="sd">        down a more stable computational graph (see details in the</span>
<span class="sd">        reconstruction cost function)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pre_sigmoid_activation</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">hbias</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_activation</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">pre_sigmoid_activation</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">sample_h_given_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; This function infers state of hidden units given visible units &#39;&#39;&#39;</span>
        <span class="c1"># compute the activation of the hidden units given a sample of</span>
        <span class="c1"># the visibles</span>
        <span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propup</span><span class="p">(</span><span class="n">v0_sample</span><span class="p">)</span>
        <span class="c1"># get a sample of the hiddens given their activation</span>
        <span class="c1"># Note that theano_rng.binomial returns a symbolic sample of dtype</span>
        <span class="c1"># int64 by default. If we want to keep our computations in floatX</span>
        <span class="c1"># for the GPU we need to specify to return the dtype floatX</span>
        <span class="n">h1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">h1_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">h1_mean</span><span class="p">,</span>
                                             <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span><span class="p">,</span> <span class="n">h1_sample</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">propdown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This function propagates the hidden units activation downwards to</span>
<span class="sd">        the visible units</span>

<span class="sd">        Note that we return also the pre_sigmoid_activation of the</span>
<span class="sd">        layer. As it will turn out later, due to how Theano deals with</span>
<span class="sd">        optimizations, this symbolic variable will be needed to write</span>
<span class="sd">        down a more stable computational graph (see details in the</span>
<span class="sd">        reconstruction cost function)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pre_sigmoid_activation</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbias</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_activation</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">pre_sigmoid_activation</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">sample_v_given_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h0_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; This function infers state of visible units given hidden units &#39;&#39;&#39;</span>
        <span class="c1"># compute the activation of the visible given the hidden sample</span>
        <span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propdown</span><span class="p">(</span><span class="n">h0_sample</span><span class="p">)</span>
        <span class="c1"># get a sample of the visible given their activation</span>
        <span class="c1"># Note that theano_rng.binomial returns a symbolic sample of dtype</span>
        <span class="c1"># int64 by default. If we want to keep our computations in floatX</span>
        <span class="c1"># for the GPU we need to specify to return the dtype floatX</span>
        <span class="n">v1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">v1_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">v1_mean</span><span class="p">,</span>
                                             <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span><span class="p">,</span> <span class="n">v1_sample</span><span class="p">]</span>
</pre></div>
</div>
<p>We can then use these functions to define the symbolic graph for a Gibbs
sampling step. We define two functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gibbs_vhv</span></code> which performs a step of Gibbs sampling starting from the
visible units. As we shall see, this will be useful for sampling from the
RBM.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gibbs_hvh</span></code> which performs a step of Gibbs sampling starting from the hidden units.
This function will be useful for performing CD and PCD updates.</p></li>
</ul>
<p>The code is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">gibbs_hvh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h0_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; This function implements one step of Gibbs sampling,</span>
<span class="sd">            starting from the hidden state&#39;&#39;&#39;</span>
        <span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span><span class="p">,</span> <span class="n">v1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_v_given_h</span><span class="p">(</span><span class="n">h0_sample</span><span class="p">)</span>
        <span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span><span class="p">,</span> <span class="n">h1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_h_given_v</span><span class="p">(</span><span class="n">v1_sample</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span><span class="p">,</span> <span class="n">v1_sample</span><span class="p">,</span>
                <span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span><span class="p">,</span> <span class="n">h1_sample</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">gibbs_vhv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; This function implements one step of Gibbs sampling,</span>
<span class="sd">            starting from the visible state&#39;&#39;&#39;</span>
        <span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span><span class="p">,</span> <span class="n">h1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_h_given_v</span><span class="p">(</span><span class="n">v0_sample</span><span class="p">)</span>
        <span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span><span class="p">,</span> <span class="n">v1_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_v_given_h</span><span class="p">(</span><span class="n">h1_sample</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pre_sigmoid_h1</span><span class="p">,</span> <span class="n">h1_mean</span><span class="p">,</span> <span class="n">h1_sample</span><span class="p">,</span>
                <span class="n">pre_sigmoid_v1</span><span class="p">,</span> <span class="n">v1_mean</span><span class="p">,</span> <span class="n">v1_sample</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that we also return the pre-sigmoid
activation. To understand why this is so you need to understand a bit about
how Theano works. Whenever you compile a Theano function, the computational
graph that you pass as input gets optimized for speed and stability. This
is done by changing several parts of the subgraphs with others. One
such optimization expresses terms of the form log(sigmoid(x)) in terms of
softplus. We need this optimization for the cross-entropy since sigmoid of
numbers larger than 30. (or even less then that) turn to 1. and numbers
smaller than  -30. turn to 0 which in terms will force theano
to compute log(0) and therefore we will get either -inf or NaN
as cost. If the value is expressed in terms of softplus we do
not get this undesirable behaviour. This optimization usually works
fine, but here we have a special case. The sigmoid is applied inside
the scan op, while the log is outside. Therefore Theano will only
see log(scan(..)) instead of log(sigmoid(..)) and will not apply
the wanted optimization. We can not go and replace the sigmoid
in scan with something else also, because this only needs to be
done on the last step. Therefore the easiest and more efficient way
is to get also the pre-sigmoid activation as an output of scan,
and apply both the log and sigmoid outside scan such that Theano
can catch and optimize the expression.</p>
<p>The class also has a function that computes the free energy of the model,
needed for computing the gradient of the parameters
(see Eq. <a class="reference internal" href="#equation-free-energy-grad">(4)</a>). Note that we also return the pre-sigmoid</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">free_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Function to compute the free energy &#39;&#39;&#39;</span>
        <span class="n">wx_b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">hbias</span>
        <span class="n">vbias_term</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbias</span><span class="p">)</span>
        <span class="n">hidden_term</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">T</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">wx_b</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">hidden_term</span> <span class="o">-</span> <span class="n">vbias_term</span>
</pre></div>
</div>
<p>We then add a <code class="docutils literal notranslate"><span class="pre">get_cost_updates</span></code> method, whose purpose is to generate the symbolic
gradients for CD-k and PCD-k updates.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_cost_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This functions implements one step of CD-k or PCD-k</span>

<span class="sd">        :param lr: learning rate used to train the RBM</span>

<span class="sd">        :param persistent: None for CD. For PCD, shared variable</span>
<span class="sd">            containing old state of Gibbs chain. This must be a shared</span>
<span class="sd">            variable of size (batch size, number of hidden units).</span>

<span class="sd">        :param k: number of Gibbs steps to do in CD-k/PCD-k</span>

<span class="sd">        Returns a proxy for the cost and the updates dictionary. The</span>
<span class="sd">        dictionary contains the update rules for weights and biases but</span>
<span class="sd">        also an update of the shared variable used to store the persistent</span>
<span class="sd">        chain, if one is used.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute positive phase</span>
        <span class="n">pre_sigmoid_ph</span><span class="p">,</span> <span class="n">ph_mean</span><span class="p">,</span> <span class="n">ph_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_h_given_v</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>

        <span class="c1"># decide how to initialize persistent chain:</span>
        <span class="c1"># for CD, we use the newly generate hidden sample</span>
        <span class="c1"># for PCD, we initialize from the old state of the chain</span>
        <span class="k">if</span> <span class="n">persistent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chain_start</span> <span class="o">=</span> <span class="n">ph_sample</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chain_start</span> <span class="o">=</span> <span class="n">persistent</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">get_cost_updates</span></code> takes as argument a variable called <code class="docutils literal notranslate"><span class="pre">persistent</span></code>. This allows us to use the same code to implement both CD and PCD.
To use PCD, <code class="docutils literal notranslate"><span class="pre">persistent</span></code> should refer to a shared variable which contains the
state of the Gibbs chain from the previous iteration.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">persistent</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, we initialize the Gibbs chain with the hidden
sample generated during the positive phase, therefore implementing CD. Once we have established the
starting point of the chain, we can then compute the sample at the end of the
Gibbs chain, sample that we need for getting the gradient (see  Eq. <a class="reference internal" href="#equation-free-energy-grad">(4)</a>). To do so, we will use the <code class="docutils literal notranslate"><span class="pre">scan</span></code>
op provided by Theano, therefore we urge the reader to look it up by following this <a class="reference external" href="http://deeplearning.net/software/theano/library/scan.html">link</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="c1"># perform actual negative phase</span>
        <span class="c1"># in order to implement CD-k/PCD-k we need to scan over the</span>
        <span class="c1"># function that implements one gibbs step k times.</span>
        <span class="c1"># Read Theano tutorial on scan for more information :</span>
        <span class="c1"># http://deeplearning.net/software/theano/library/scan.html</span>
        <span class="c1"># the scan will return the entire Gibbs chain</span>
        <span class="p">(</span>
            <span class="p">[</span>
                <span class="n">pre_sigmoid_nvs</span><span class="p">,</span>
                <span class="n">nv_means</span><span class="p">,</span>
                <span class="n">nv_samples</span><span class="p">,</span>
                <span class="n">pre_sigmoid_nhs</span><span class="p">,</span>
                <span class="n">nh_means</span><span class="p">,</span>
                <span class="n">nh_samples</span>
            <span class="p">],</span>
            <span class="n">updates</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gibbs_hvh</span><span class="p">,</span>
            <span class="c1"># the None are place holders, saying that</span>
            <span class="c1"># chain_start is the initial state corresponding to the</span>
            <span class="c1"># 6th output</span>
            <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">chain_start</span><span class="p">],</span>
            <span class="n">n_steps</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gibbs_hvh&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>Once we have the generated the chain we take the sample at the end of the
chain to get the free energy of the negative phase. Note that the
<code class="docutils literal notranslate"><span class="pre">chain_end</span></code> is a symbolical Theano variable expressed in terms of the model
parameters, and if we would apply <code class="docutils literal notranslate"><span class="pre">T.grad</span></code> naively, the function will
try to go through the Gibbs chain to get the gradients. This is not what we
want (it will mess up our gradients) and therefore we need to indicate to
<code class="docutils literal notranslate"><span class="pre">T.grad</span></code> that <code class="docutils literal notranslate"><span class="pre">chain_end</span></code> is a constant. We do this by using the argument
<code class="docutils literal notranslate"><span class="pre">consider_constant</span></code> of <code class="docutils literal notranslate"><span class="pre">T.grad</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="c1"># determine gradients on RBM parameters</span>
        <span class="c1"># note that we only need the sample at the end of the chain</span>
        <span class="n">chain_end</span> <span class="o">=</span> <span class="n">nv_samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cost</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">))</span> <span class="o">-</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">free_energy</span><span class="p">(</span><span class="n">chain_end</span><span class="p">))</span>
        <span class="c1"># We must not compute the gradient through the gibbs sampling</span>
        <span class="n">gparams</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">consider_constant</span><span class="o">=</span><span class="p">[</span><span class="n">chain_end</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, we add to the updates dictionary returned by scan (which contains
updates rules for random states of <code class="docutils literal notranslate"><span class="pre">theano_rng</span></code>) to contain the parameter
updates. In the case of PCD, these should also update the shared variable
containing the state of the Gibbs chain.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="c1"># constructs the update dictionary</span>
        <span class="k">for</span> <span class="n">gparam</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="c1"># make sure that the learning rate is of the right dtype</span>
            <span class="n">updates</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span> <span class="o">-</span> <span class="n">gparam</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                <span class="n">lr</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">persistent</span><span class="p">:</span>
            <span class="c1"># Note that this works only if persistent is a shared variable</span>
            <span class="n">updates</span><span class="p">[</span><span class="n">persistent</span><span class="p">]</span> <span class="o">=</span> <span class="n">nh_samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># pseudo-likelihood is a better proxy for PCD</span>
            <span class="n">monitoring_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pseudo_likelihood_cost</span><span class="p">(</span><span class="n">updates</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># reconstruction cross-entropy is a better proxy for CD</span>
            <span class="n">monitoring_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reconstruction_cost</span><span class="p">(</span><span class="n">updates</span><span class="p">,</span>
                                                           <span class="n">pre_sigmoid_nvs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">monitoring_cost</span><span class="p">,</span> <span class="n">updates</span>
</pre></div>
</div>
<section id="tracking-progress">
<h3>Tracking Progress<a class="headerlink" href="#tracking-progress" title="Permalink to this heading">¶</a></h3>
<p>RBMs are particularly tricky to train. Because of the partition function
<span class="math notranslate nohighlight">\(Z\)</span> of Eq. <a class="reference internal" href="#equation-energy1">(1)</a>, we cannot estimate the log-likelihood
<span class="math notranslate nohighlight">\(\log(P(x))\)</span> during training. We therefore have no direct useful metric
for choosing the optimal hyperparameters.</p>
<p>Several options are available to the user.</p>
<p><strong>Inspection of Negative Samples</strong></p>
<p>Negative samples obtained during training can be visualized. As training
progresses, we know that the model defined by the RBM becomes closer to the
true underlying distribution, <span class="math notranslate nohighlight">\(p_{train}(x)\)</span>. Negative samples should thus
look like samples from the training set. Obviously bad hyperparameters can be
discarded in this fashion.</p>
<p><strong>Visual Inspection of Filters</strong></p>
<p>The filters learnt by the model can be visualized. This amounts to plotting
the weights of each unit as a gray-scale image (after reshaping to a square
matrix). Filters should pick out strong features in the data. While it is not
clear for an arbitrary dataset, what these features should look like, training
on MNIST usually results in filters which act as stroke detectors, while
training on natural images lead to Gabor like filters if trained in
conjunction with a sparsity criteria.</p>
<p><strong>Proxies to Likelihood</strong></p>
<p>Other, more tractable functions can be used as a proxy to the likelihood.  When
training an RBM with PCD, one can use pseudo-likelihood as the proxy.
Pseudo-likelihood (PL) is much less expensive to compute, as it assumes that
all bits are independent. Therefore,</p>
<div class="math notranslate nohighlight">
\[\begin{split}PL(x) = \prod_i P(x_i | x_{-i}) \text{ and }\\
\log PL(x) = \sum_i \log P(x_i | x_{-i})\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(x_{-i}\)</span> denotes the set of all bits of <span class="math notranslate nohighlight">\(x\)</span> except bit
<span class="math notranslate nohighlight">\(i\)</span>. The log-PL is therefore the sum of the log-probabilities of each
bit <span class="math notranslate nohighlight">\(x_i\)</span>, conditioned on the state of all other bits. For MNIST, this
would involve summing over the 784 input dimensions, which remains rather
expensive. For this reason, we use the following stochastic approximation to
log-PL:</p>
<div class="math notranslate nohighlight">
\[\begin{split}g = N \cdot \log P(x_i | x_{-i}) \text{, where } i \sim U(0,N), \text{, and}\\
E[ g ] = \log PL(x)\end{split}\]</div>
<p>where the expectation is taken over the uniform random choice of index <span class="math notranslate nohighlight">\(i\)</span>,
and <span class="math notranslate nohighlight">\(N\)</span> is the number of visible units. In order to work with binary
units, we further introduce the notation <span class="math notranslate nohighlight">\(\tilde{x}_i\)</span> to refer to
<span class="math notranslate nohighlight">\(x\)</span> with bit-i being flipped (1-&gt;0, 0-&gt;1). The log-PL for an RBM with binary units is
then written as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\log PL(x) &amp;\approx N \cdot \log
   \frac {e^{-FE(x)}} {e^{-FE(x)} + e^{-FE(\tilde{x}_i)}} \\
&amp;\approx N \cdot \log[ sigm (FE(\tilde{x}_i) - FE(x)) ]\end{split}\]</div>
<p>We therefore return this cost as well as the RBM updates in the  <code class="docutils literal notranslate"><span class="pre">get_cost_updates</span></code> function of the <code class="docutils literal notranslate"><span class="pre">RBM</span></code> class.
Notice that we modify the updates dictionary to increment the
index of bit <span class="math notranslate nohighlight">\(i\)</span>. This will result in bit <span class="math notranslate nohighlight">\(i\)</span> cycling over all possible
values <span class="math notranslate nohighlight">\(\{0,1,...,N\}\)</span>, from one update to another.</p>
<p>Note that for CD training the cross-entropy cost between the input and the
reconstruction (the same as the one used for the de-noising autoencoder) is more reliable then the pseudo-loglikelihood. Here is the code we use to
compute the pseudo-likelihood:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_pseudo_likelihood_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stochastic approximation to the pseudo-likelihood&quot;&quot;&quot;</span>

        <span class="c1"># index of bit i in expression p(x_i | x_{\i})</span>
        <span class="n">bit_i_idx</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;bit_i_idx&#39;</span><span class="p">)</span>

        <span class="c1"># binarize the input image by rounding to nearest integer</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>

        <span class="c1"># calculate free energy for the given bit configuration</span>
        <span class="n">fe_xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_energy</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="c1"># flip bit x_i of matrix xi and preserve all other bits x_{\i}</span>
        <span class="c1"># Equivalent to xi[:,bit_i_idx] = 1-xi[:, bit_i_idx], but assigns</span>
        <span class="c1"># the result to xi_flip, instead of working in place on xi.</span>
        <span class="n">xi_flip</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">set_subtensor</span><span class="p">(</span><span class="n">xi</span><span class="p">[:,</span> <span class="n">bit_i_idx</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:,</span> <span class="n">bit_i_idx</span><span class="p">])</span>

        <span class="c1"># calculate free energy with bit flipped</span>
        <span class="n">fe_xi_flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_energy</span><span class="p">(</span><span class="n">xi_flip</span><span class="p">)</span>

        <span class="c1"># equivalent to e^(-FE(x_i)) / (e^(-FE(x_i)) + e^(-FE(x_{\i})))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_visible</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">fe_xi_flip</span> <span class="o">-</span>
                                                            <span class="n">fe_xi</span><span class="p">)))</span>

        <span class="c1"># increment bit_i_idx % number as part of updates</span>
        <span class="n">updates</span><span class="p">[</span><span class="n">bit_i_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit_i_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_visible</span>

        <span class="k">return</span> <span class="n">cost</span>
</pre></div>
</div>
</section>
<section id="main-loop">
<h3>Main Loop<a class="headerlink" href="#main-loop" title="Permalink to this heading">¶</a></h3>
<p>We now have all the necessary ingredients to start training our network.</p>
<p>Before going over the training loop however, the reader should familiarize
himself with the function <code class="docutils literal notranslate"><span class="pre">tile_raster_images</span></code> (see <a class="reference internal" href="utilities.html#how-to-plot"><span class="std std-ref">Plotting Samples and Filters</span></a>). Since
RBMs are generative models, we are interested in sampling from them and
plotting/visualizing these samples. We also want to visualize the filters
(weights) learnt by the RBM, to gain insights into what the RBM is actually
doing. Bear in mind however, that this does not provide the entire story,
since we neglect the biases and plot the weights up to a multiplicative
constant (weights are converted to values between 0 and 1).</p>
<p>Having these utility functions, we can start training the RBM and plot/save
the filters after each training epoch.  We train the RBM using PCD, as it has
been shown to lead to a better generative model (<a class="reference internal" href="references.html#tieleman08" id="id3"><span>[Tieleman08]</span></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># it is ok for a theano function to have no output</span>
    <span class="c1"># the purpose of train_rbm is solely to update the RBM parameters</span>
    <span class="n">train_rbm</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
        <span class="p">[</span><span class="n">index</span><span class="p">],</span>
        <span class="n">cost</span><span class="p">,</span>
        <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
        <span class="n">givens</span><span class="o">=</span><span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">train_set_x</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">]</span>
        <span class="p">},</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;train_rbm&#39;</span>
    <span class="p">)</span>

    <span class="n">plotting_time</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

    <span class="c1"># go through training epochs</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">training_epochs</span><span class="p">):</span>

        <span class="c1"># go through the training set</span>
        <span class="n">mean_cost</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">batch_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_train_batches</span><span class="p">):</span>
            <span class="n">mean_cost</span> <span class="o">+=</span> <span class="p">[</span><span class="n">train_rbm</span><span class="p">(</span><span class="n">batch_index</span><span class="p">)]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Training epoch </span><span class="si">%d</span><span class="s1">, cost is &#39;</span> <span class="o">%</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_cost</span><span class="p">))</span>

        <span class="c1"># Plot filters after each training epoch</span>
        <span class="n">plotting_start</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="c1"># Construct image from the weight matrix</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span>
            <span class="n">tile_raster_images</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="n">rbm</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">img_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span>
                <span class="n">tile_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="n">tile_spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;filters_at_epoch_</span><span class="si">%i</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">epoch</span><span class="p">)</span>
        <span class="n">plotting_stop</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="n">plotting_time</span> <span class="o">+=</span> <span class="p">(</span><span class="n">plotting_stop</span> <span class="o">-</span> <span class="n">plotting_start</span><span class="p">)</span>

    <span class="n">end_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

    <span class="n">pretraining_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">plotting_time</span>

    <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Training took </span><span class="si">%f</span><span class="s1"> minutes&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pretraining_time</span> <span class="o">/</span> <span class="mf">60.</span><span class="p">))</span>
</pre></div>
</div>
<p>Once the RBM is trained, we can then use the <code class="docutils literal notranslate"><span class="pre">gibbs_vhv</span></code> function to implement
the Gibbs chain required for sampling. We initialize the Gibbs chain starting
from test examples (although we could as well pick it from the training set)
in order to speed up convergence and avoid problems with random
initialization. We again use Theano’s <code class="docutils literal notranslate"><span class="pre">scan</span></code> op to do 1000 steps before
each plotting.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="c1">#################################</span>
    <span class="c1">#     Sampling from the RBM     #</span>
    <span class="c1">#################################</span>
    <span class="c1"># find out the number of test samples</span>
    <span class="n">number_of_test_samples</span> <span class="o">=</span> <span class="n">test_set_x</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># pick random test examples, with which to initialize the persistent chain</span>
    <span class="n">test_idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">number_of_test_samples</span> <span class="o">-</span> <span class="n">n_chains</span><span class="p">)</span>
    <span class="n">persistent_vis_chain</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">test_set_x</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">test_idx</span><span class="p">:</span><span class="n">test_idx</span> <span class="o">+</span> <span class="n">n_chains</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Next we create the 20 persistent chains in parallel to get our
samples. To do so, we compile a theano function which performs one Gibbs step
and updates the state of the persistent chain with the new visible sample. We
apply this function iteratively for a large number of steps, plotting the
samples at every 1000 steps.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">plot_every</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="c1"># define one step of Gibbs sampling (mf = mean-field) define a</span>
    <span class="c1"># function that does `plot_every` steps before returning the</span>
    <span class="c1"># sample for plotting</span>
    <span class="p">(</span>
        <span class="p">[</span>
            <span class="n">presig_hids</span><span class="p">,</span>
            <span class="n">hid_mfs</span><span class="p">,</span>
            <span class="n">hid_samples</span><span class="p">,</span>
            <span class="n">presig_vis</span><span class="p">,</span>
            <span class="n">vis_mfs</span><span class="p">,</span>
            <span class="n">vis_samples</span>
        <span class="p">],</span>
        <span class="n">updates</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
        <span class="n">rbm</span><span class="o">.</span><span class="n">gibbs_vhv</span><span class="p">,</span>
        <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">persistent_vis_chain</span><span class="p">],</span>
        <span class="n">n_steps</span><span class="o">=</span><span class="n">plot_every</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gibbs_vhv&quot;</span>
    <span class="p">)</span>

    <span class="c1"># add to updates the shared variable that takes care of our persistent</span>
    <span class="c1"># chain :.</span>
    <span class="n">updates</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">persistent_vis_chain</span><span class="p">:</span> <span class="n">vis_samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]})</span>
    <span class="c1"># construct the function that implements our persistent chain.</span>
    <span class="c1"># we generate the &quot;mean field&quot; activations for plotting and the actual</span>
    <span class="c1"># samples for reinitializing the state of our persistent chain</span>
    <span class="n">sample_fn</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
        <span class="p">[],</span>
        <span class="p">[</span>
            <span class="n">vis_mfs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">vis_samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">],</span>
        <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;sample_fn&#39;</span>
    <span class="p">)</span>

    <span class="c1"># create a space to store the image for plotting ( we need to leave</span>
    <span class="c1"># room for the tile_spacing as well)</span>
    <span class="n">image_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">29</span> <span class="o">*</span> <span class="n">n_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">29</span> <span class="o">*</span> <span class="n">n_chains</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="c1"># generate `plot_every` intermediate samples that we discard,</span>
        <span class="c1"># because successive samples in the chain are too correlated</span>
        <span class="n">vis_mf</span><span class="p">,</span> <span class="n">vis_sample</span> <span class="o">=</span> <span class="n">sample_fn</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ... plotting sample </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">image_data</span><span class="p">[</span><span class="mi">29</span> <span class="o">*</span> <span class="n">idx</span><span class="p">:</span><span class="mi">29</span> <span class="o">*</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">28</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">tile_raster_images</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">vis_mf</span><span class="p">,</span>
            <span class="n">img_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span>
            <span class="n">tile_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_chains</span><span class="p">),</span>
            <span class="n">tile_spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># construct image</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">image_data</span><span class="p">)</span>
    <span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;samples.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this heading">¶</a></h2>
<p>We ran the code with PCD-15, learning rate of 0.1 and a batch size of 20, for
15 epochs. Training the model takes 122.466 minutes on a Intel Xeon E5430 &#64;
2.66GHz CPU, with a single-threaded GotoBLAS.</p>
<p>The output was the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>...<span class="w"> </span>loading<span class="w"> </span>data
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">0</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-90.6507246003
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-81.235857373
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-74.9120966945
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">3</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-73.0213216101
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">4</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-68.4098570497
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">5</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-63.2693021647
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">6</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-65.99578971
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">7</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-68.1236650015
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">8</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-68.3207365087
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">9</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-64.2949797113
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">10</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-61.5194867893
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">11</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-61.6539369402
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">12</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-63.5465278086
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">13</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-63.3787093527
Training<span class="w"> </span>epoch<span class="w"> </span><span class="m">14</span>,<span class="w"> </span>cost<span class="w"> </span>is<span class="w">  </span>-62.755739271
Training<span class="w"> </span>took<span class="w"> </span><span class="m">122</span>.466000<span class="w"> </span>minutes
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">0</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">1</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">2</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">3</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">4</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">5</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">6</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">7</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">8</span>
<span class="w"> </span>...<span class="w"> </span>plotting<span class="w"> </span>sample<span class="w">  </span><span class="m">9</span>
</pre></div>
</div>
<p>The pictures below show the filters after 15 epochs:</p>
<figure class="align-center" id="id4">
<img alt="_images/filters_at_epoch_14.png" src="_images/filters_at_epoch_14.png" />
<figcaption>
<p><span class="caption-text">Filters obtained after 15 epochs.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Here are the samples generated by the RBM after training. Each row
represents a mini-batch of negative particles (samples from independent Gibbs
chains). 1000 steps of Gibbs sampling were taken between each of those rows.</p>
<figure class="align-center">
<img alt="_images/samples.png" src="_images/samples.png" />
</figure>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="contents.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Restricted Boltzmann Machines (RBM)</a><ul>
<li><a class="reference internal" href="#energy-based-models-ebm">Energy-Based Models (EBM)</a></li>
<li><a class="reference internal" href="#id1">Restricted Boltzmann Machines (RBM)</a></li>
<li><a class="reference internal" href="#sampling-in-an-rbm">Sampling in an RBM</a><ul>
<li><a class="reference internal" href="#contrastive-divergence-cd-k">Contrastive Divergence (CD-k)</a></li>
<li><a class="reference internal" href="#persistent-cd">Persistent CD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#tracking-progress">Tracking Progress</a></li>
<li><a class="reference internal" href="#main-loop">Main Loop</a></li>
</ul>
</li>
<li><a class="reference internal" href="#results">Results</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="SdA.html"
                          title="previous chapter">Stacked Denoising Autoencoders (SdA)</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="DBN.html"
                          title="next chapter">Deep Belief Networks</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/rbm.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="DBN.html" title="Deep Belief Networks"
             >next</a> |</li>
        <li class="right" >
          <a href="SdA.html" title="Stacked Denoising Autoencoders (SdA)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">DeepLearning 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Restricted Boltzmann Machines (RBM)</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2008--2010, LISA lab.
      Last updated on May 11, 2023.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>

  </body>
</html>