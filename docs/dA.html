
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Denoising Autoencoders (dA) &#8212; DeepLearning 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Stacked Denoising Autoencoders (SdA)" href="SdA.html" />
    <link rel="prev" title="Convolutional Neural Networks (LeNet)" href="lenet.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-168290-9']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SdA.html" title="Stacked Denoising Autoencoders (SdA)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lenet.html" title="Convolutional Neural Networks (LeNet)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">DeepLearning 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Denoising Autoencoders (dA)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="denoising-autoencoders-da">
<span id="daa"></span><h1>Denoising Autoencoders (dA)<a class="headerlink" href="#denoising-autoencoders-da" title="Permalink to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section assumes the reader has already read through <a class="reference internal" href="logreg.html"><span class="doc">Classifying MNIST digits using Logistic Regression</span></a>
and <a class="reference internal" href="mlp.html"><span class="doc">Multilayer Perceptron</span></a>. Additionally it uses the following Theano functions
and concepts: <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html?highlight=tanh">T.tanh</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#using-shared-variables">shared variables</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/adding.html#adding-two-scalars">basic arithmetic ops</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#computing-gradients">T.grad</a>, <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/examples.html#using-random-numbers">Random numbers</a>, <a class="reference external" href="http://deeplearning.net/software/theano/library/config.html#config.floatX">floatX</a>. If you intend to run the code on GPU also read <a class="reference external" href="http://deeplearning.net/software/theano/tutorial/using_gpu.html">GPU</a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code for this section is available for download <a class="reference external" href="http://deeplearning.net/tutorial/code/dA.py">here</a>.</p>
</div>
<p>The Denoising Autoencoder (dA) is an extension of a classical
autoencoder and it was introduced as a building block for deep networks
in <a class="reference internal" href="references.html#vincent08" id="id1"><span>[Vincent08]</span></a>. We will start the tutorial with a short discussion on
<a class="reference internal" href="#autoencoders"><span class="std std-ref">Autoencoders</span></a>.</p>
<section id="autoencoders">
<span id="id2"></span><h2>Autoencoders<a class="headerlink" href="#autoencoders" title="Permalink to this heading">¶</a></h2>
<p>See section 4.6 of <a class="reference internal" href="references.html#bengio09" id="id3"><span>[Bengio09]</span></a> for an overview of auto-encoders.
An autoencoder takes an input <span class="math">\mathbf{x} \in [0,1]^d</span> and first
maps it (with an <em>encoder)</em> to a hidden representation <span class="math">\mathbf{y} \in [0,1]^{d'}</span>
through a deterministic mapping, e.g.:</p>
<div class="math">
<p><span class="math">\mathbf{y} = s(\mathbf{W}\mathbf{x} + \mathbf{b})</span></p>
</div><p>Where <span class="math">s</span> is a non-linearity such as the sigmoid. The latent
representation <span class="math">\mathbf{y}</span>, or <strong>code</strong> is then mapped back (with a
<em>decoder)</em> into a <strong>reconstruction</strong> <span class="math">\mathbf{z}</span> of the same shape as
<span class="math">\mathbf{x}</span>. The mapping happens through a similar transformation, e.g.:</p>
<div class="math">
<p><span class="math">\mathbf{z} = s(\mathbf{W'}\mathbf{y} + \mathbf{b'})</span></p>
</div><p>(Here, the prime symbol does not indicate matrix transposition.)
<span class="math">\mathbf{z}</span> should be seen as a prediction of <span class="math">\mathbf{x}</span>, given
the code <span class="math">\mathbf{y}</span>. Optionally, the weight matrix <span class="math">\mathbf{W'}</span>
of the reverse mapping may be constrained to be the transpose of the forward
mapping: <span class="math">\mathbf{W'} = \mathbf{W}^T</span>. This is referred to as <em>tied
weights</em>. The parameters of this model (namely <span class="math">\mathbf{W}</span>,
<span class="math">\mathbf{b}</span>, <span class="math">\mathbf{b'}</span> and, if one doesn’t use tied weights,
also <span class="math">\mathbf{W'}</span>) are optimized such that the average reconstruction
error is minimized.</p>
<p>The reconstruction error can be measured in many ways, depending on the
appropriate distributional assumptions on the input given the code. The
traditional <em>squared error</em> <span class="math">L(\mathbf{x} \mathbf{z}) = || \mathbf{x} -
\mathbf{z} ||^2</span>, can be used. If the input is interpreted as either bit
vectors or vectors of bit probabilities, <em>cross-entropy</em> of the reconstruction
can be used:</p>
<div class="math">
<p><span class="math">L_{H} (\mathbf{x}, \mathbf{z}) = - \sum^d_{k=1}[\mathbf{x}_k \log
        \mathbf{z}_k + (1 - \mathbf{x}_k)\log(1 - \mathbf{z}_k)]</span></p>
</div><p>The hope is that the code <span class="math">\mathbf{y}</span> is a <em>distributed</em> representation
that captures the coordinates along the main factors of variation in the data.
This is similar to the way the projection on principal components would capture
the main factors of variation in the data. Indeed, if there is one linear
hidden layer (the <em>code)</em> and the mean squared error criterion is used to train
the network, then the <span class="math">k</span> hidden units learn to project the input in the
span of the first <span class="math">k</span> principal components of the data. If the hidden
layer is non-linear, the auto-encoder behaves differently from PCA, with the
ability to capture multi-modal aspects of the input distribution. The departure
from PCA becomes even more important when we consider <em>stacking multiple
encoders</em> (and their corresponding decoders) when building a deep auto-encoder
<a class="reference internal" href="references.html#hinton06" id="id4"><span>[Hinton06]</span></a>.</p>
<p>Because <span class="math">\mathbf{y}</span> is viewed as a lossy compression of
<span class="math">\mathbf{x}</span>, it cannot be a good (small-loss) compression for all
<span class="math">\mathbf{x}</span>. Optimization makes it a good compression for training
examples, and hopefully for other inputs as well, but not for arbitrary inputs.
That is the sense in which an auto-encoder generalizes: it gives low
reconstruction error on test examples from the same distribution as the
training examples, but generally high reconstruction error on samples randomly
chosen from the input space.</p>
<p>We want to implement an auto-encoder using Theano, in the form of a class, that
could be afterwards used in constructing a stacked autoencoder. The first step
is to create shared variables for the parameters of the autoencoder
<span class="math">\mathbf{W}</span>, <span class="math">\mathbf{b}</span> and <span class="math">\mathbf{b'}</span>. (Since we are
using tied weights in this tutorial, <span class="math">\mathbf{W}^T</span> will be used for
<span class="math">\mathbf{W'}</span>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numpy_rng</span><span class="p">,</span>
        <span class="n">theano_rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_visible</span><span class="o">=</span><span class="mi">784</span><span class="p">,</span>
        <span class="n">n_hidden</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bhid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bvis</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the dA class by specifying the number of visible units (the</span>
<span class="sd">        dimension d of the input ), the number of hidden units ( the dimension</span>
<span class="sd">        d&#39; of the latent or hidden space ) and the corruption level. The</span>
<span class="sd">        constructor also receives symbolic variables for the input, weights and</span>
<span class="sd">        bias. Such a symbolic variables are useful when, for example the input</span>
<span class="sd">        is the result of some computations, or when weights are shared between</span>
<span class="sd">        the dA and an MLP layer. When dealing with SdAs this always happens,</span>
<span class="sd">        the dA on layer 2 gets as input the output of the dA on layer 1,</span>
<span class="sd">        and the weights of the dA are used in the second stage of training</span>
<span class="sd">        to construct an MLP.</span>

<span class="sd">        :type numpy_rng: numpy.random.RandomState</span>
<span class="sd">        :param numpy_rng: number random generator used to generate weights</span>

<span class="sd">        :type theano_rng: theano.tensor.shared_randomstreams.RandomStreams</span>
<span class="sd">        :param theano_rng: Theano random generator; if None is given one is</span>
<span class="sd">                     generated based on a seed drawn from `rng`</span>

<span class="sd">        :type input: theano.tensor.TensorType</span>
<span class="sd">        :param input: a symbolic description of the input or None for</span>
<span class="sd">                      standalone dA</span>

<span class="sd">        :type n_visible: int</span>
<span class="sd">        :param n_visible: number of visible units</span>

<span class="sd">        :type n_hidden: int</span>
<span class="sd">        :param n_hidden:  number of hidden units</span>

<span class="sd">        :type W: theano.tensor.TensorType</span>
<span class="sd">        :param W: Theano variable pointing to a set of weights that should be</span>
<span class="sd">                  shared belong the dA and another architecture; if dA should</span>
<span class="sd">                  be standalone set this to None</span>

<span class="sd">        :type bhid: theano.tensor.TensorType</span>
<span class="sd">        :param bhid: Theano variable pointing to a set of biases values (for</span>
<span class="sd">                     hidden units) that should be shared belong dA and another</span>
<span class="sd">                     architecture; if dA should be standalone set this to None</span>

<span class="sd">        :type bvis: theano.tensor.TensorType</span>
<span class="sd">        :param bvis: Theano variable pointing to a set of biases values (for</span>
<span class="sd">                     visible units) that should be shared belong dA and another</span>
<span class="sd">                     architecture; if dA should be standalone set this to None</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_visible</span> <span class="o">=</span> <span class="n">n_visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hidden</span> <span class="o">=</span> <span class="n">n_hidden</span>

        <span class="c1"># create a Theano random generator that gives symbolic random values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">theano_rng</span><span class="p">:</span>
            <span class="n">theano_rng</span> <span class="o">=</span> <span class="n">RandomStreams</span><span class="p">(</span><span class="n">numpy_rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">))</span>

        <span class="c1"># note : W&#39; was written as `W_prime` and b&#39; as `b_prime`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">W</span><span class="p">:</span>
            <span class="c1"># W is initialized with `initial_W` which is uniformely sampled</span>
            <span class="c1"># from -4*sqrt(6./(n_visible+n_hidden)) and</span>
            <span class="c1"># 4*sqrt(6./(n_hidden+n_visible))the output of uniform if</span>
            <span class="c1"># converted using asarray to dtype</span>
            <span class="c1"># theano.config.floatX so that the code is runable on GPU</span>
            <span class="n">initial_W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="n">numpy_rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">high</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_visible</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
            <span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">initial_W</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bvis</span><span class="p">:</span>
            <span class="n">bvis</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_visible</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bhid</span><span class="p">:</span>
            <span class="n">bhid</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_hidden</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">W</span>
        <span class="c1"># b corresponds to the bias of the hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">bhid</span>
        <span class="c1"># b_prime corresponds to the bias of the visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span> <span class="o">=</span> <span class="n">bvis</span>
        <span class="c1"># tied weights, therefore W_prime is W transpose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_prime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span> <span class="o">=</span> <span class="n">theano_rng</span>
        <span class="c1"># if no input is given, generate a variable representing the input</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we use a matrix because we expect a minibatch of several</span>
            <span class="c1"># examples, each example being a row</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dmatrix</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that we pass the symbolic <code class="docutils literal notranslate"><span class="pre">input</span></code> to the autoencoder as a parameter.
This is so that we can concatenate layers of autoencoders to form a deep
network: the symbolic output (the <span class="math">\mathbf{y}</span> above) of layer <span class="math">k</span> will
be the symbolic input of layer <span class="math">k+1</span>.</p>
<p>Now we can express the computation of the latent representation and of the reconstructed
signal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_hidden_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Computes the values of the hidden layer &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_reconstructed_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the reconstructed input given the values of the</span>
<span class="sd">        hidden layer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_prime</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span><span class="p">)</span>
</pre></div>
</div>
<p>And using these functions we can compute the cost and the updates of
one stochastic gradient descent step:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_cost_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; This function computes the cost and the updates for one trainng</span>
<span class="sd">        step of the dA &quot;&quot;&quot;</span>

        <span class="n">tilde_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corrupted_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hidden_values</span><span class="p">(</span><span class="n">tilde_x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reconstructed_input</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># note : we sum over the size of a datapoint; if we are using</span>
        <span class="c1">#        minibatches, L will be a vector, with one entry per</span>
        <span class="c1">#        example in minibatch</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># note : L is now a vector, where each element is the</span>
        <span class="c1">#        cross-entropy cost of the reconstruction of the</span>
        <span class="c1">#        corresponding example of the minibatch. We need to</span>
        <span class="c1">#        compute the average of all these to get the cost of</span>
        <span class="c1">#        the minibatch</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># compute the gradients of the cost of the `dA` with respect</span>
        <span class="c1"># to its parameters</span>
        <span class="n">gparams</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># generate the list of updates</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">param</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gparam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">gparam</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">gparams</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">updates</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now define a function that applied iteratively will update the
parameters <code class="docutils literal notranslate"><span class="pre">W</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">b_prime</span></code> such that the
reconstruction cost is approximately minimized.</p>
<p>If there is no constraint besides minimizing the reconstruction error, one
might expect an auto-encoder with <span class="math">n</span> inputs and an encoding of dimension
<span class="math">n</span> (or greater) to learn the identity function, merely mapping an input
to its copy. Such an autoencoder would not differentiate test examples (from
the training distribution) from other input configurations.</p>
<p>Surprisingly,
experiments reported in <a class="reference internal" href="references.html#bengio07" id="id5"><span>[Bengio07]</span></a> suggest that, in practice, when trained
with stochastic gradient descent, non-linear auto-encoders with more hidden
units than inputs (called overcomplete) yield useful representations. (Here,
“useful” means that a network taking the encoding as input has low
classification error.)</p>
<p>A simple explanation is that stochastic gradient descent with early stopping is
similar to an L2 regularization of the parameters. To achieve perfect
reconstruction of continuous inputs, a one-hidden layer auto-encoder with
non-linear hidden units (exactly like in the above code) needs very small
weights in the first (encoding) layer, to bring the non-linearity of the hidden
units into their linear regime, and very large weights in the second (decoding)
layer. With binary inputs, very large weights are also needed to completely
minimize the reconstruction error. Since the implicit or explicit
regularization makes it difficult to reach large-weight solutions, the
optimization algorithm finds encodings which only work well for examples
similar to those in the training set, which is what we want. It means that the
<em>representation is exploiting statistical regularities present in the training
set,</em> rather than merely learning to replicate the input.</p>
<p>There are other ways by which an auto-encoder with more hidden units than inputs
could be prevented from learning the identity function, capturing something
useful about the input in its hidden representation. One is the addition of
<em>sparsity</em> (forcing many of the hidden units to be zero or near-zero). Sparsity
has been exploited very successfully by many <a class="reference internal" href="references.html#ranzato07" id="id6"><span>[Ranzato07]</span></a> <a class="reference internal" href="references.html#lee08" id="id7"><span>[Lee08]</span></a>. Another is
to add randomness in the transformation from input to reconstruction. This
technique is used in Restricted Boltzmann Machines (discussed later in
<a class="reference internal" href="rbm.html#rbm"><span class="std std-ref">Restricted Boltzmann Machines (RBM)</span></a>), as well as in Denoising Auto-Encoders, discussed below.</p>
</section>
<section id="denoising-autoencoders">
<span id="da"></span><h2>Denoising Autoencoders<a class="headerlink" href="#denoising-autoencoders" title="Permalink to this heading">¶</a></h2>
<p>The idea behind denoising autoencoders is simple. In order to force
the hidden layer to discover more robust features and prevent it
from simply learning the identity, we train the
autoencoder to <em>reconstruct the input from a corrupted version of it</em>.</p>
<p>The denoising auto-encoder is a stochastic version of the auto-encoder.
Intuitively, a denoising auto-encoder does two things: try to encode the input
(preserve the information about the input), and try to undo the effect of a
corruption process stochastically applied to the input of the auto-encoder. The
latter can only be done by capturing the statistical dependencies between the
inputs. The denoising auto-encoder can be understood from different
perspectives (the manifold learning perspective, stochastic operator
perspective, bottom-up – information theoretic perspective, top-down –
generative model perspective), all of which are explained in <a class="reference internal" href="references.html#vincent08" id="id8"><span>[Vincent08]</span></a>. See
also section 7.2 of <a class="reference internal" href="references.html#bengio09" id="id9"><span>[Bengio09]</span></a> for an overview of auto-encoders.</p>
<p>In <a class="reference internal" href="references.html#vincent08" id="id10"><span>[Vincent08]</span></a>, the stochastic corruption process randomly sets some of the
inputs (as many as half of them) to zero. Hence the denoising auto-encoder is
trying to <em>predict the corrupted (i.e. missing) values from the uncorrupted
(i.e., non-missing) values</em>, for randomly selected subsets of missing patterns.
Note how being able to predict any subset of variables from the rest is a
sufficient condition for completely capturing the joint distribution between a
set of variables (this is how Gibbs sampling works).</p>
<p>To convert the autoencoder class into a denoising autoencoder class, all we
need to do is to add a stochastic corruption step operating on the input. The input can be
corrupted in many ways, but in this tutorial we will stick to the original
corruption mechanism of randomly masking entries of the input by making
them zero. The code below
does just that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_corrupted_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function keeps ``1-corruption_level`` entries of the inputs the</span>
<span class="sd">        same and zero-out randomly selected subset of size ``corruption_level``</span>
<span class="sd">        Note : first argument of theano.rng.binomial is the shape(size) of</span>
<span class="sd">               random numbers that it should produce</span>
<span class="sd">               second argument is the number of trials</span>
<span class="sd">               third argument is the probability of success of any trial</span>

<span class="sd">                this will produce an array of 0s and 1s where 1 has a</span>
<span class="sd">                probability of 1 - ``corruption_level`` and 0 with</span>
<span class="sd">                ``corruption_level``</span>

<span class="sd">                The binomial function return int64 data type by</span>
<span class="sd">                default.  int64 multiplicated by the input</span>
<span class="sd">                type(floatX) always return float64.  To keep all data</span>
<span class="sd">                in floatX when floatX is float32, we set the dtype of</span>
<span class="sd">                the binomial to floatX. As in our case the value of</span>
<span class="sd">                the binomial is always 0 or 1, this don&#39;t change the</span>
<span class="sd">                result. This is needed to allow the gpu to work</span>
<span class="sd">                correctly as it only support float32 for now.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">p</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corruption_level</span><span class="p">,</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span><span class="p">)</span> <span class="o">*</span> <span class="nb">input</span>
</pre></div>
</div>
<p>In the stacked autoencoder class (<a class="reference internal" href="SdA.html#stacked-autoencoders"><span class="std std-ref">Stacked Autoencoders</span></a>) the weights of
the <code class="docutils literal notranslate"><span class="pre">dA</span></code> class have to be shared with those of a corresponding sigmoid layer.
For this reason, the constructor of the <code class="docutils literal notranslate"><span class="pre">dA</span></code> also gets Theano variables
pointing to the shared parameters. If those parameters are left to <code class="docutils literal notranslate"><span class="pre">None</span></code>,
new ones will be constructed.</p>
<p>The final denoising autoencoder class becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">dA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Denoising Auto-Encoder class (dA)</span>

<span class="sd">    A denoising autoencoders tries to reconstruct the input from a corrupted</span>
<span class="sd">    version of it by projecting it first in a latent space and reprojecting</span>
<span class="sd">    it afterwards back in the input space. Please refer to Vincent et al.,2008</span>
<span class="sd">    for more details. If x is the input then equation (1) computes a partially</span>
<span class="sd">    destroyed version of x by means of a stochastic mapping q_D. Equation (2)</span>
<span class="sd">    computes the projection of the input into the latent space. Equation (3)</span>
<span class="sd">    computes the reconstruction of the input, while equation (4) computes the</span>
<span class="sd">    reconstruction error.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tilde{x} ~ q_D(\tilde{x}|x)                                     (1)</span>

<span class="sd">        y = s(W \tilde{x} + b)                                           (2)</span>

<span class="sd">        x = s(W&#39; y  + b&#39;)                                                (3)</span>

<span class="sd">        L(x,z) = -sum_{k=1}^d [x_k \log z_k + (1-x_k) \log( 1-z_k)]      (4)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numpy_rng</span><span class="p">,</span>
        <span class="n">theano_rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_visible</span><span class="o">=</span><span class="mi">784</span><span class="p">,</span>
        <span class="n">n_hidden</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bhid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bvis</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the dA class by specifying the number of visible units (the</span>
<span class="sd">        dimension d of the input ), the number of hidden units ( the dimension</span>
<span class="sd">        d&#39; of the latent or hidden space ) and the corruption level. The</span>
<span class="sd">        constructor also receives symbolic variables for the input, weights and</span>
<span class="sd">        bias. Such a symbolic variables are useful when, for example the input</span>
<span class="sd">        is the result of some computations, or when weights are shared between</span>
<span class="sd">        the dA and an MLP layer. When dealing with SdAs this always happens,</span>
<span class="sd">        the dA on layer 2 gets as input the output of the dA on layer 1,</span>
<span class="sd">        and the weights of the dA are used in the second stage of training</span>
<span class="sd">        to construct an MLP.</span>

<span class="sd">        :type numpy_rng: numpy.random.RandomState</span>
<span class="sd">        :param numpy_rng: number random generator used to generate weights</span>

<span class="sd">        :type theano_rng: theano.tensor.shared_randomstreams.RandomStreams</span>
<span class="sd">        :param theano_rng: Theano random generator; if None is given one is</span>
<span class="sd">                     generated based on a seed drawn from `rng`</span>

<span class="sd">        :type input: theano.tensor.TensorType</span>
<span class="sd">        :param input: a symbolic description of the input or None for</span>
<span class="sd">                      standalone dA</span>

<span class="sd">        :type n_visible: int</span>
<span class="sd">        :param n_visible: number of visible units</span>

<span class="sd">        :type n_hidden: int</span>
<span class="sd">        :param n_hidden:  number of hidden units</span>

<span class="sd">        :type W: theano.tensor.TensorType</span>
<span class="sd">        :param W: Theano variable pointing to a set of weights that should be</span>
<span class="sd">                  shared belong the dA and another architecture; if dA should</span>
<span class="sd">                  be standalone set this to None</span>

<span class="sd">        :type bhid: theano.tensor.TensorType</span>
<span class="sd">        :param bhid: Theano variable pointing to a set of biases values (for</span>
<span class="sd">                     hidden units) that should be shared belong dA and another</span>
<span class="sd">                     architecture; if dA should be standalone set this to None</span>

<span class="sd">        :type bvis: theano.tensor.TensorType</span>
<span class="sd">        :param bvis: Theano variable pointing to a set of biases values (for</span>
<span class="sd">                     visible units) that should be shared belong dA and another</span>
<span class="sd">                     architecture; if dA should be standalone set this to None</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_visible</span> <span class="o">=</span> <span class="n">n_visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hidden</span> <span class="o">=</span> <span class="n">n_hidden</span>

        <span class="c1"># create a Theano random generator that gives symbolic random values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">theano_rng</span><span class="p">:</span>
            <span class="n">theano_rng</span> <span class="o">=</span> <span class="n">RandomStreams</span><span class="p">(</span><span class="n">numpy_rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">))</span>

        <span class="c1"># note : W&#39; was written as `W_prime` and b&#39; as `b_prime`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">W</span><span class="p">:</span>
            <span class="c1"># W is initialized with `initial_W` which is uniformely sampled</span>
            <span class="c1"># from -4*sqrt(6./(n_visible+n_hidden)) and</span>
            <span class="c1"># 4*sqrt(6./(n_hidden+n_visible))the output of uniform if</span>
            <span class="c1"># converted using asarray to dtype</span>
            <span class="c1"># theano.config.floatX so that the code is runable on GPU</span>
            <span class="n">initial_W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="n">numpy_rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                    <span class="n">low</span><span class="o">=-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">high</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">6.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_hidden</span> <span class="o">+</span> <span class="n">n_visible</span><span class="p">)),</span>
                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_visible</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
            <span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">initial_W</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bvis</span><span class="p">:</span>
            <span class="n">bvis</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_visible</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bhid</span><span class="p">:</span>
            <span class="n">bhid</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="n">n_hidden</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span>
                <span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                <span class="n">borrow</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">W</span>
        <span class="c1"># b corresponds to the bias of the hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">bhid</span>
        <span class="c1"># b_prime corresponds to the bias of the visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span> <span class="o">=</span> <span class="n">bvis</span>
        <span class="c1"># tied weights, therefore W_prime is W transpose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_prime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span> <span class="o">=</span> <span class="n">theano_rng</span>
        <span class="c1"># if no input is given, generate a variable representing the input</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we use a matrix because we expect a minibatch of several</span>
            <span class="c1"># examples, each example being a row</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dmatrix</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_corrupted_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function keeps ``1-corruption_level`` entries of the inputs the</span>
<span class="sd">        same and zero-out randomly selected subset of size ``corruption_level``</span>
<span class="sd">        Note : first argument of theano.rng.binomial is the shape(size) of</span>
<span class="sd">               random numbers that it should produce</span>
<span class="sd">               second argument is the number of trials</span>
<span class="sd">               third argument is the probability of success of any trial</span>

<span class="sd">                this will produce an array of 0s and 1s where 1 has a</span>
<span class="sd">                probability of 1 - ``corruption_level`` and 0 with</span>
<span class="sd">                ``corruption_level``</span>

<span class="sd">                The binomial function return int64 data type by</span>
<span class="sd">                default.  int64 multiplicated by the input</span>
<span class="sd">                type(floatX) always return float64.  To keep all data</span>
<span class="sd">                in floatX when floatX is float32, we set the dtype of</span>
<span class="sd">                the binomial to floatX. As in our case the value of</span>
<span class="sd">                the binomial is always 0 or 1, this don&#39;t change the</span>
<span class="sd">                result. This is needed to allow the gpu to work</span>
<span class="sd">                correctly as it only support float32 for now.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">theano_rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">p</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corruption_level</span><span class="p">,</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">floatX</span><span class="p">)</span> <span class="o">*</span> <span class="nb">input</span>

    <span class="k">def</span> <span class="nf">get_hidden_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Computes the values of the hidden layer &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_reconstructed_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the reconstructed input given the values of the</span>
<span class="sd">        hidden layer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_prime</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_prime</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cost_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; This function computes the cost and the updates for one trainng</span>
<span class="sd">        step of the dA &quot;&quot;&quot;</span>

        <span class="n">tilde_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corrupted_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">corruption_level</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hidden_values</span><span class="p">(</span><span class="n">tilde_x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reconstructed_input</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># note : we sum over the size of a datapoint; if we are using</span>
        <span class="c1">#        minibatches, L will be a vector, with one entry per</span>
        <span class="c1">#        example in minibatch</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span> <span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># note : L is now a vector, where each element is the</span>
        <span class="c1">#        cross-entropy cost of the reconstruction of the</span>
        <span class="c1">#        corresponding example of the minibatch. We need to</span>
        <span class="c1">#        compute the average of all these to get the cost of</span>
        <span class="c1">#        the minibatch</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># compute the gradients of the cost of the `dA` with respect</span>
        <span class="c1"># to its parameters</span>
        <span class="n">gparams</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># generate the list of updates</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">param</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gparam</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">gparam</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">gparams</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">updates</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="putting-it-all-together">
<h2>Putting it All Together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this heading">¶</a></h2>
<p>It is easy now to construct an instance of our <code class="docutils literal notranslate"><span class="pre">dA</span></code> class and train
it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># allocate symbolic variables for the data</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">lscalar</span><span class="p">()</span>    <span class="c1"># index to a [mini]batch</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  <span class="c1"># the data is presented as rasterized images</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="c1">#####################################</span>
    <span class="c1"># BUILDING THE MODEL CORRUPTION 30% #</span>
    <span class="c1">#####################################</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
    <span class="n">theano_rng</span> <span class="o">=</span> <span class="n">RandomStreams</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">))</span>

    <span class="n">da</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span>
        <span class="n">numpy_rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
        <span class="n">theano_rng</span><span class="o">=</span><span class="n">theano_rng</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">n_visible</span><span class="o">=</span><span class="mi">28</span> <span class="o">*</span> <span class="mi">28</span><span class="p">,</span>
        <span class="n">n_hidden</span><span class="o">=</span><span class="mi">500</span>
    <span class="p">)</span>

    <span class="n">cost</span><span class="p">,</span> <span class="n">updates</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">get_cost_updates</span><span class="p">(</span>
        <span class="n">corruption_level</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="n">learning_rate</span>
    <span class="p">)</span>

    <span class="n">train_da</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
        <span class="p">[</span><span class="n">index</span><span class="p">],</span>
        <span class="n">cost</span><span class="p">,</span>
        <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
        <span class="n">givens</span><span class="o">=</span><span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">train_set_x</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

    <span class="c1">############</span>
    <span class="c1"># TRAINING #</span>
    <span class="c1">############</span>

    <span class="c1"># go through training epochs</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">training_epochs</span><span class="p">):</span>
        <span class="c1"># go through trainng set</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">batch_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_train_batches</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_da</span><span class="p">(</span><span class="n">batch_index</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Training epoch </span><span class="si">%d</span><span class="s1">, cost &#39;</span> <span class="o">%</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">))</span>

    <span class="n">end_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

    <span class="n">training_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;The 30</span><span class="si">% c</span><span class="s1">orruption code for file &#39;</span> <span class="o">+</span>
           <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
           <span class="s1">&#39; ran for </span><span class="si">%.2f</span><span class="s1">m&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">training_time</span> <span class="o">/</span> <span class="mf">60.</span><span class="p">)),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to get a feeling of what the network learned we are going to
plot the filters (defined by the weight matrix). Bear in mind, however,
that this does not provide the entire story,
since we neglect the biases and plot the weights up to a multiplicative
constant (weights are converted to values between 0 and 1).</p>
<p>To plot our filters we will need the help of <code class="docutils literal notranslate"><span class="pre">tile_raster_images</span></code> (see
<a class="reference internal" href="utilities.html#how-to-plot"><span class="std std-ref">Plotting Samples and Filters</span></a>) so we urge the reader to study it. Also
using the help of the Python Image Library, the following lines of code will
save the filters as an image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">tile_raster_images</span><span class="p">(</span>
        <span class="n">X</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">borrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="n">img_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">tile_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">tile_spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;filters_corruption_30.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="running-the-code">
<h2>Running the Code<a class="headerlink" href="#running-the-code" title="Permalink to this heading">¶</a></h2>
<p>To run the code:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python<span class="w"> </span>dA.py
</pre></div>
</div>
<p>The resulted filters when we do not use any noise are:</p>
<figure class="align-center">
<img alt="_images/filters_corruption_0.png" src="_images/filters_corruption_0.png" />
</figure>
<p>The filters for 30 percent noise:</p>
<figure class="align-center">
<img alt="_images/filters_corruption_30.png" src="_images/filters_corruption_30.png" />
</figure>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="contents.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Denoising Autoencoders (dA)</a><ul>
<li><a class="reference internal" href="#autoencoders">Autoencoders</a></li>
<li><a class="reference internal" href="#denoising-autoencoders">Denoising Autoencoders</a></li>
<li><a class="reference internal" href="#putting-it-all-together">Putting it All Together</a></li>
<li><a class="reference internal" href="#running-the-code">Running the Code</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="lenet.html"
                          title="previous chapter">Convolutional Neural Networks (LeNet)</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="SdA.html"
                          title="next chapter">Stacked Denoising Autoencoders (SdA)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/dA.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SdA.html" title="Stacked Denoising Autoencoders (SdA)"
             >next</a> |</li>
        <li class="right" >
          <a href="lenet.html" title="Convolutional Neural Networks (LeNet)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">DeepLearning 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Denoising Autoencoders (dA)</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2008--2010, LISA lab.
      Last updated on Mar 20, 2023.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>

  </body>
</html>